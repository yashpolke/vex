***Bend multiples curves randomly:***
```ruby
float seed = chf('seed');
int points[] = primpoints(0, @primnum); 

matrix3 matrx = ident();
float angle = radians( chf('angle') ) * rand(@ptnum+seed);
vector axis = {1, 0, 0};

vector init_pos = point(0, "P", points[0]);
vector prev_pos = init_pos;

for (int n=0; n<len(points); n++){
    vector curr_pos = point(0, "P", points[n]);
    rotate(matrx, angle, axis);
    
    // init_pos *= 0.01; // spiral
    vector new_pos = (curr_pos - init_pos)*matrx + prev_pos;
    init_pos = curr_pos;
    prev_pos = new_pos;
    
    setpointattrib(0, "P", points[n], new_pos); 
    }
 ```
------------------------------------------------------------------------------------------------------------------------


Control emission direction

if(!haspointattrib(0, 'id')) i@id = i@ptnum;

vector src    = getbbox_center(0);
vector target = getbbox_center(1);

//Get direction
vector dir = `chs('change_dir')`1*normalize(target - src);

//Get mmagnitude
float mag = distance(src, target) * chf('magnitude_mult');

//Set magnitude randomness
float rand = fit01(rand(@ptnum), ch('rand_v_var_limitx'), ch('rand_v_var_limity'));
int rndss = chi('randomness');
vector condition = (rndss != 1) ? (v@v = dir * mag) : (v@v = dir * mag * rand);

//Set directional randomness
vector out = normalize(@P - src) * mag;
int drndss = chi('directional_randomness');
float bias = chf('bias');
float dseed = chf('directional_seed');
v@v = lerp(v@v, out, bias * rand(@ptnum+dseed));

//Set initial random rotations
float amount = radians(fit01(rand(@id), -ch('init_anglex'), ch('init_angley')));
vector seed;
seed.x = rand(@id+1);
seed.y = rand(@id+2);
seed.z = rand(@id+3);
vector axis = fit01(rand(seed),{-1,-1,-1},{1,1,1});
matrix rm=ident();
rotate(rm, amount, axis);
v@v = v@v * rm;
v@w = vector(fit01(rand(@ptnum), ch('angular_w_varx'), ch('angular_w_vary'))) * length(v@v);
p@orient = {0, 0, 0, 1};
----------------------------------------------------------------------------------------------------------------------------
Xform matrix for volumes:

float angle      = chf('angle');
vector axis      = chv('axis');
vector translate = chv('translate');
vector scale     = chv('scale');

//store old position
vector o_pos = @P;

//extract matrix
matrix m4 = primintrinsic(0, 'packedfulltransform', 0);

//put to origin
@P *= invert(m4);

//make matrix for xforms
matrix rm = ident();
rotate(rm, angle, axis);
translate(rm, translate);
scale(rm, scale);
setprimintrinsic(0, 'transform', i@primnum, rm, 'mult');

//put it back
@P = o_pos;
----------------------------------------------------------------------------------------------------------------------
Minpos ray:
float d = chf('distance');

int nearpoint = nearpoint(1, @P);

vector nearpos = point(1, 'P', nearpoint);

@P = minpos(1, nearpos, d);
----------------------------------------------------------------------------------------------------------------------
Matrix to origin:
vector min = {0, 0, 0};
vector max = {0, 0, 0};
getpointbbox(0, min, max);
vector centroid = (max + min)/2.0;

// Build and apply transformation matrix
vector translate = centroid;
vector rotate = chv('rotation');
vector scale = chv('scale');
matrix xform = invert(maketransform(0, 0, translate, rotate, scale));
@P *= xform;

// Store transformation matrix in attribute
4@xform_matrix = xform;
----------------------------------------------------------------------------------------------------------------------
Facing ratio:
vector cam_pt = -normalize(point(1, 'P', 0));
vector N      = normalize(@N);

v@Cd = chramp("ramp", pow(dot(N, cam_pt), 1));
----------------------------------------------------------------------------------------------------------------------

Lerp dent:

float bias = chf('bias');
float e_corr = chf('e_corr');

vector primpos;
float u, v;

int nearpoint  = nearpoint(1, v@P);
//vector nearpos = normalize(v@P - point(1, 'P', nearpoint));

vector orig = v@P;
//vector dir = nearpos;
vector dir = normalize(point(1, 'N', nearpoint));

int prim_num = intersect(1, orig, dir, primpos, u, v);

v@P += dir*e_corr;
v@P = lerp(primpos, v@P, bias);


----------------------------------------------------------------------------------------------------------------------
Facing ratio:
vector cam_pt = -normalize(point(1, 'P', 0));
vector N      = normalize(@N);

v@Cd = chramp("ramp", pow(dot(N, cam_pt), 1));
--------------------------------------------------------------------------------------------------------------------------
Create resampled line:

int resample = chi('resample');

int points[];
resize(points, resample);

vector p1 = getbbox_center(1);
vector p2 = getbbox_center(2);

float length = length(p2 - p1);
vector dir = normalize(p2 - p1);

float step = length/(resample-1);

for(int i=0; i<resample; i++){
    vector pos = p1 + (dir * (step * i));
    int id     = addpoint(0, pos);
    points[i]  = id;
}
addprim(0, 'polyline', points);
--------------------------------------------------------------------------------------------------------------------------
Calculate largest piece:
float maxvol = 0;
i@largest = -1;
for (int i=0; i<@numprim; i++) {
    float bounds[] = primintrinsic(0, "bounds", i);
    float volume = (bounds[1]-bounds[0])*(bounds[3]-bounds[2])*(bounds[5]-bounds[4]);
    if (volume>maxvol) {
        maxvol = volume;
        @largest = i;
    }
}

--------------------------------------------------------------------------------------------------------------------------
Anim age:

float af = fit01(rand(@id), chf('startframe'), chf('endframe'));
float life = chf('life');
f@af = af;


float anim_value = fit(@Frame, af, af+life, 0, 1);

f@age = ((af + anim_value))%1;

f@norm_age = f@age / life;

float ramp = chramp('grad_ramp', clamp(f@grad*f@age,0,1));

//f@test = f@grad * f@age;
if(@Frame < af || @Frame >af+life){
    v@Cd *= {0,0,0};       
}
else{
    v@Cd *= ramp;

//    v@Cd = ramp * f@grad * f@age;
}

--------------------------------------------------------------------------------------------------------------------------


//Copy pieces to points with rotations
int seed = chi('seed');

vector4 __orient = point(1, 'orient', i@ptnum);
matrix3 __rm     = qconvert(__orient);
float __pscale   = point(1, 'pscale', i@ptnum);

//match position to points
v@P = point(1, 'P', i@ptnum+seed);

//make identity matrix for scaling
matrix3 __im   = ident();
vector __scale = set(__pscale, __pscale, __pscale);
scale(__im, __scale);
__rm *= __im;

//set transform matrix
setprimintrinsic(geoself(), 'transform', i@primnum, __rm, 'mult');


--------------------------------------------------------------------------------------------------------------------------
Create rotation matrix:
///Create local matrix
v@pos = v@P;

vector zero = point(0, 'P', 0);
vector one = point(0, 'P', 1);
vector two = point(0, 'P', 2);

v@x = normalize(one - zero);
v@y = normalize(cross(v@x, (two - zero)));
v@z = normalize(cross(v@x, v@y));

///Create rotation matrix
//Get vectors
vector x = point(1, 'x', i@ptnum);
vector y = point(1, 'y', i@ptnum);
vector z = point(1, 'z', i@ptnum);

//make 3x3 matrix current
matrix3 m31 = set(v@x, v@y, v@z);
//make 3x3 matrix destination
matrix3 m32 = set(x, y, z);

//matrix to extract
matrix m4 = matrix(invert(m31) * m32);

//extract rotation
vector rotation = cracktransform(0, 0, 1, {0,0,0}, m4);

vector pos1 = point(1, 'pos', i@ptnum);

//get translation
vector translate = pos1 - v@pos;

//create rotation matrix
4@xform = maketransform(0, 0, translate, rotation, {1,1,1}, v@pos, {0,0,0}, {0,0,0});

///After use attribCopy to transfer rotation matrix attribute don't match P along with transform by attribute

-------------------------------------------------------------------------------------------------------------------------
Color by bbox:
float e = chf('e');

v@Cd = {0,0,0};

float value = pow(1-relbbox(v@P).`chs('axis')`, e);

setcomp(v@Cd, value, atoi(chs('num_component')));

-------------------------------------------------------------------------------------------------------------------------

Create lines by proximity:
float maxdist = chf( 'maxdist' );
// Create an array of points to be queried
int nearpts[] = nearpoints( 0, v@P, maxdist );

foreach( int pt; nearpts ){
    if( pt != i@ptnum ){
        int line = addprim( 0, 'polyline' );
        addvertex( 0, line, i@ptnum );
        addvertex( 0, line, pt );
        }
}

Create Lines:
int i;
int p1 = @opinput1_ptnum;
for ( i = 0; i < i@numpt; i++ )
{
    int line = addprim( geoself(), "polyline" );
    addvertex(geoself(), line, i);
    addvertex(geoself(), line, p1);
    
}   
-------------------------------------------------------------------------------------------------------------------------
Cull by frame duration:
float start = chf( 'start' );
float end   = chf( 'end' );
float duration = chf( 'duration' );

if (@Frame < start || @Frame > end ) removepoint(0,@ptnum);
-------------------------------------------------------------------------------------------------------------------------
Curve line in axes:

float amp = chf( 'amp' );
float pow = chf( 'pow' );

float grad = pow( float( @ptnum ) / ( float( @numpt - 1 ) ), pow);

// Cuve in axes
int condition_x = ch( "axis" ) == 0;
int condition_y = ch( "axis" ) == 1;
int condition_z = ch( "axis" ) == 2;


if ( condition_`chs( "axis" )` ) {
    @P.`chs( "axis" )` `chs( "sign" )`= chramp( "ramp", grad ) * amp;
    }

-------------------------------------------------------------------------------------------------------------------------
Group by axis:
vector min, max;
getbbox( min, max );

if ( @P.z <= min.z + chf( 'thresh' ) ) ( @group_left = 1 ); else( @group_right = 1 );


-------------------------------------------------------------------------------------------------------------------------
Group name to attr:
i@`chs("group_name")` = 1;
-------------------------------------------------------------------------------------------------------------------------
Iso by VolumeSample:
float sdf = volumesample( s@OpInput2, 0, v@P );

int condition_on = sdf > 0;
int condition_off = sdf < 0;

if ( condition_`chs("iso")` )
{
    removepoint( 0, i@ptnum );
}
-------------------------------------------------------------------------------------------------------------------------
Iso pieces by dist:
float maxdist = chf( "maxDist" );
int maxpoints = chi( "maxPoints" );

i@pts = pcfind( s@OpInput2, "P", v@P, maxdist, maxpoints )[1];

f@dist = distance( v@P, point( 1, "P", i@pts ) );

if ( f@dist <= chf( "thresh" ) )
{
    @group_activeChunks = 1;
}
else
{
    @group_inactiveChunks = 1;
}
-------------------------------------------------------------------------------------------------------------------------
Lerp vecs:
float i = chf( 'interpolation' );
string sv = chs( 'sv' );
vector vec1 = point( 1, sv, i@ptnum );

v@v = lerp( v@v, vec1, i  );
-------------------------------------------------------------------------------------------------------------------------
Names by class:
s@name = sprintf( "unique_name_&d", i@class );
-------------------------------------------------------------------------------------------------------------------------
Particles rots:
v@N = normalize(fit01(rand(@ptnum+1), (vector) -1, (vector) 1));

f@rot_mag = fit01(rand(@ptnum+2), ch("rot_min"), ch("rot_max"));

v@rot_axis = fit01(rand(@ptnum+3), (vector) 1, (vector) -1);
v@rot_axis = normalize(v@rot_axis);

f@pscale = fit01(chramp("pscaleRamp", rand(@ptnum+4)), ch("pscale_min"), ch("pscale_max"));


v@v += v@N * 0.1;
-------------------------------------------------------------------------------------------------------------------------
Particles v variation:
//ID ATTRIBUTE
if (!hasattrib(0, 'point', 'id')) i@id = int(i@ptnum + @Frame);

//PREOFFSET
v@P += v@v * (@TimeInc * rand(@id) * ch("preoffset"));

//ANGLE VARIATION
float amount = radians(fit01(rand(@id), -ch("angle"), ch("angle")));
vector seed;
seed.x = rand(@id+1);
seed.y = rand(@id+2);
seed.z = rand(@id+3);

vector axis = fit01(rand(seed),{-1,-1,-1},{1,1,1});
matrix rm=ident();
rotate(rm, amount, axis);
v@v = v@v * rm;

//MAGNITUDE VARIATION
v@v *= fit01(rand(@id),ch("min"),ch("max"));

//ADDITIONAL VEL DIRECTION
vector v_dir0 = normalize(v@v);
vector v_dir1 = chv("dir1");
vector v_dir2 = chv("dir2");
if (ch("dir1_isRefPoint")) v_dir1 = normalize(v@P - v_dir1);
if (ch("dir2_isRefPoint")) v_dir2 = normalize(v@P - v_dir2);
vector v_dir = normalize(v_dir0*ch("dir0Weight") + v_dir1*ch("dir1Weight") + v_dir2*ch("dir2Weight"));

//CLAMP TO MAX VEL
float v_mag = clamp(length(v@v), 0, ch("maxvel"));
v@v = v_dir * v_mag;

//POST OFFSET
v@P += v@v * (@TimeInc * rand(@id) * ch("postoffset"));
-------------------------------------------------------------------------------------------------------------------------
Pscale by age:
float pow  = chf( 'exponent' );
float mult = chf( 'mult' );

// Declare pscale
f@pscale = fit01(pow(rand(@ptnum * chf( "seed" ) ),chf("pow")),chf("pscale1"),chf("pscale2"));

//Mult pscale by age
f@pscale *= pow( chramp( 'ageRamp', f@nage ), pow ) * mult;

//Viz
v@Cd = f@pscale;
-------------------------------------------------------------------------------------------------------------------------
Pscale by camdist:
float pow  = chf( 'pow' );

vector cp = point( 1, 'P', 0 );
float dist = distance( v@P, cp );

v@Cd = pow( chramp( 'ramp', dist ), pow );

f@pscale *= pow( chramp( 'ramp', dist ), pow );
-------------------------------------------------------------------------------------------------------------------------
Remove overlapping points:
float @pscale = 0;
vector @P;
int @ptnum;

float searchradius = @pscale * 2;

if (len(pcfind(1, 'P', @P, searchradius, 1)))
    removepoint(geoself(), @ptnum);
-------------------------------------------------------------------------------------------------------------------------
Rotate vecs:
float x_angle = chf( 'x_angle' );
float y_angle = chf( 'y_angle' );
float z_angle = chf( 'z_angle' );

vector x_axis = chv( 'x_axis' );
vector y_axis = chv( 'y_axis' );
vector z_axis = chv( 'z_axis' );

vector4 xquats = quaternion( x_angle, x_axis );
vector4 yquats = quaternion( y_angle, y_axis );
vector4 zquats = quaternion( z_angle, z_axis );

matrix3 x_rotationMatrix = qconvert( xquats );
matrix3 y_rotationMatrix = qconvert( yquats );
matrix3 z_rotationMatrix = qconvert( zquats );

v@v *= x_rotationMatrix;
v@v *= y_rotationMatrix;
v@v *= z_rotationMatrix;
-------------------------------------------------------------------------------------------------------------------------
Sustain:
float frame = @Frame;
float fInterval1 = chf( "fInt1" );
float fInterval2 = chf( "fInt2" );

@i = fit01( sin (floor( @Frame ) ),$RFSTART,$RFEND  );
@u = fit01( rint( rand( i@ptnum ) ),1,50 ) * fit01( anoise( @Time ),0,1 );

if ( @i <= chf( "iThresh" ) || @u>= chf( "uThresh" )  )
{
    removepoint( 0, i@ptnum );   
}
-------------------------------------------------------------------------------------------------------------------------
POPS rots:
matrix rm=ident();
rotate(rm, radians(f@rot_mag), v@rot_axis);

v@N = normalize(v@N * rm);
v@w = (v@rot_axis * radians(f@rot_mag) * (1/@TimeInc));

v@up = cross(v@N, v@rot_axis);
-------------------------------------------------------------------------------------------------------------------------
Sops rots:
v@N = normalize(fit01(rand(@ptnum+1), (vector) -1, (vector) 1));

f@rot_mag = fit01(rand(@ptnum+2), ch("rot_min"), ch("rot_max"));

v@rot_axis = fit01(rand(@ptnum+3), (vector) 1, (vector) -1);
v@rot_axis = normalize(v@rot_axis);

f@pscale = fit01(chramp("pscaleRamp", rand(@ptnum+4)), ch("pscale_min"), ch("pscale_max"));


v@v += v@N * 15;

-------------------------------------------------------------------------------------------------------------------------
Blur density by velocity:

float fps = 1.0/ch("fps");

vector vel = volumesamplev(1, "vel", v@P);
float steps = max(float(ch("steps")), 2);
float d_mult = 1.0/steps;
float s_mult = -d_mult*0.5;
float sum = 0.0;
int i;

for(i=0; i<steps; ++i)
{
float d = volumesample(0, "density", v@P - vel*fps*ch("length")*s_mult);
sum += d * d_mult;
s_mult += d_mult;
}

f@density = sum;
-------------------------------------------------------------------------------------------------------------------------
***String concat****
s@`chs('string_attribute')` = concat('`chs('name_value')`_', itoa(int(i@`chs('connectivity_attr')`)));
-------------------------------------------------------------------------------------------------------------------------
***Attrib expression***

if(@`chs('attribute')``chs('condition')` chf('threshold')){
    `chs('operation')`;
}
-------------------------------------------------------------------------------------------------------------------------
***Nearpoint grad conical***
int nearpt = nearpoint(1, v@P);
float grad = point(1, 'grad', nearpt);
vector p2  = point(1, 'P', nearpt);
float bias = chf('bias');

v@P = lerp(v@P, p2, bias * grad);
-------------------------------------------------------------------------------------------------------------------------
***Stick primuv***
i@sourceprim;
v@sourceprimuv;

float d = xyzdist(1, v@P, i@sourceprim, v@sourceprimuv);
vector pos = primuv(1, 'P', i@sourceprim, v@sourceprimuv);

v@P = pos;
-------------------------------------------------------------------------------------------------------------------------
***Stretch along velocity***
vector v = v@v * @TimeInc;
float d = dot( normalize(v@v), normalize(v@N) );

v@P += v*d * chf('mult');
-------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------
